<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode 练习 | Insular Oasis</title><meta name="keywords" content="Leetcode,数据结构"><meta name="author" content="张海达"><meta name="copyright" content="张海达"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="5-3LC 395  380  1499 *LC1081&#x2F;316 不同字符的最小子序列 [Medium]返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。  注意：该题与 316 https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;remove-duplicate-letters&#x2F; 相同  示例 1：   输入：s &#x3D; &quot;bcabc&quot; 输出：&quot;abc&quot;   示例">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode 练习">
<meta property="og:url" content="https://no-existence.github.io/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/index.html">
<meta property="og:site_name" content="Insular Oasis">
<meta property="og:description" content="5-3LC 395  380  1499 *LC1081&#x2F;316 不同字符的最小子序列 [Medium]返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。  注意：该题与 316 https:&#x2F;&#x2F;leetcode.com&#x2F;problems&#x2F;remove-duplicate-letters&#x2F; 相同  示例 1：   输入：s &#x3D; &quot;bcabc&quot; 输出：&quot;abc&quot;   示例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://no-existence.github.io/img/cover/Leetcode.png">
<meta property="article:published_time" content="2022-05-02T09:11:01.000Z">
<meta property="article:modified_time" content="2022-05-17T04:57:06.135Z">
<meta property="article:author" content="张海达">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://no-existence.github.io/img/cover/Leetcode.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://no-existence.github.io/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leetcode 练习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-17 12:57:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/Leetcode.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Insular Oasis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leetcode 练习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-02T09:11:01.000Z" title="发表于 2022-05-02 17:11:01">2022-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-17T04:57:06.135Z" title="更新于 2022-05-17 12:57:06">2022-05-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leetcode 练习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="5-3"><a href="#5-3" class="headerlink" title="5-3"></a>5-3</h1><p>LC 395  380  1499</p>
<h3 id="LC1081-316-不同字符的最小子序列-Medium"><a href="#LC1081-316-不同字符的最小子序列-Medium" class="headerlink" title="*LC1081/316 不同字符的最小子序列 [Medium]"></a>*LC1081/316 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/">不同字符的最小子序列</a> [Medium]</h3><p>返回 <code>s</code> 字典序最小的子序列，该子序列包含 <code>s</code> 的所有不同字符，且只包含一次。</p>

<p><strong>注意：</strong>该题与 316 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicate-letters/">https://leetcode.com/problems/remove-duplicate-letters/</a> 相同</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong><code>s = "bcabc"</code>
<strong>输出<code>：</code></strong><code>"abc"</code>
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong><code>s = "cbacdcbc"</code>
<strong>输出：</strong><code>"acdb"</code></pre>
<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= s.length <= 1000</code></li>
    <li><code>s</code> 由小写英文字母组成</li>
</ul>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>类似LC402，不过略有变化。</p>
<p>维护递增的单调栈，栈内存有所有类别的字符时栈所表示的字符串就是一个可能的最优结果。</p>
<p>首先，如果入栈字符在栈内已经出现过，则不能将其入栈，视为直接出栈处理（即计数器自减1）。</p>
<p>其次，每个字母都有出栈次数的限制。如果当前出栈的字母是最后一次出现的，则不能出栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestSubsequence</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> types = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(count,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>) types++;</span><br><span class="line">            count[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 压栈元素如果在先前出现过，则不压栈，跳过</span></span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sb.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sb.charAt(j)==s.charAt(i)) &#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                count[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = sb.length();</span><br><span class="line">            <span class="comment">// 字符出栈时，如果是最后一次出现该字符，则不能出栈。</span></span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">0</span>&amp;&amp;(count[sb.charAt(n-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>]&gt;<span class="number">1</span>)&amp;&amp;sb.charAt(n-<span class="number">1</span>)&gt;=s.charAt(i))&#123;</span><br><span class="line">                count[sb.charAt(n-<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                sb.deleteCharAt(n-<span class="number">1</span>);</span><br><span class="line">                n=sb.length();</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">            <span class="comment">// 取最优的sb字符串</span></span><br><span class="line">            <span class="keyword">if</span>(sb.length()==types)&#123;</span><br><span class="line">                <span class="keyword">if</span>(result==<span class="keyword">null</span></span><br><span class="line">                   || Objects.compare(result,sb.toString(),String::compareTo)&gt;<span class="number">0</span>)</span><br><span class="line">                    result = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LC402-移掉-K-位数字-Medium"><a href="#LC402-移掉-K-位数字-Medium" class="headerlink" title="* LC402 移掉 K 位数字 [Medium]"></a>* LC402 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits/">移掉 K 位数字</a> [Medium]</h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code><em> </em>位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>


<p><strong>示例 1 ：</strong></p>

<pre>
<strong>输入：</strong>num = "1432219", k = 3
<strong>输出：</strong>"1219"
<strong>解释：</strong>移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
</pre>

<p><strong>示例 2 ：</strong></p>

<pre>
<strong>输入：</strong>num = "10200", k = 1
<strong>输出：</strong>"200"
<strong>解释：</strong>移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
</pre>

<p><strong>示例 3 ：</strong></p>

<pre>
<strong>输入：</strong>num = "10", k = 2
<strong>输出：</strong>"0"
<strong>解释：</strong>从原数字移除所有的数字，剩余为空就是 0 。
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 <= k <= num.length <= 10<sup>5</sup></code></li>
    <li><code>num</code> 仅由若干位数字（0 - 9）组成</li>
    <li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li>
</ul>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>*也可以用单调栈+贪心的方法。此题是单调栈解决删除序列部分元素使得序列序最小问题的一个典型题目。</p>
<p>这里提供另一种解法。</p>
<p>维护一个长度为(num.length-k)的队列，将num字符串从头开始依次入队。</p>
<p>为维护这个队列，设立一个指针pos，初始指向队首。</p>
<p>当队列满时，检查pos和pos+1位的数字的大小关系。如果$Q[pos]&gt;Q[pos+1]$，则表明删除Q[pos]能使得结果更小，此时只需删除Q[pos]后让pos减一（这里需要减一，因为不能保证原来$Q[pos-1]\le Q[pos+1]$，Q[pos-1]仍可能会是被删除的）。否则我们不断后移pos找到第一个使得$Q[pos]&gt;Q[pos+1]$ 的位置。</p>
<p>例如，num=”21089203” , k=4。我们需要维护一个长度为4的队列，同时在队尾虚设一位方便比较。</p>
<ol>
<li><code>2 1 0 8 | 9</code>   pos指向2，由于2&lt;1，我们删除2，9入队</li>
<li><code>1 0 8 9 | 2</code>  pos指向1，由于1&lt;0，我们删除1，2入队</li>
<li><code>0 8 9 2 | 0</code>  pos后移至9，删除9，0入队</li>
<li><code>0 8 2 0 | 3</code>  pos指向8，删除8，3入队</li>
</ol>
<p>最终结果 <code>0 2 3 0</code> 。记得去除前导0。</p>
<p>这里我们用StringBuffer来做这个队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(num);</span><br><span class="line">sb.deleteCharAt(index); <span class="comment">//删除队列中指定下标的字符</span></span><br><span class="line">sb.charAt(index);  <span class="comment">//获取某个指定下标的字符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> buffferSize = num.length()-k;</span><br><span class="line">        <span class="keyword">if</span>(buffferSize==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(num.substring(<span class="number">0</span>,buffferSize));</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=buffferSize;i&lt;num.length();i++)&#123;</span><br><span class="line">            sb.append(num.charAt(i));</span><br><span class="line">            <span class="keyword">while</span>(pos+<span class="number">1</span>&lt;sb.length()&amp;&amp;sb.charAt(pos)&lt;=sb.charAt(pos+<span class="number">1</span>))</span><br><span class="line">                pos++;</span><br><span class="line">            sb.deleteCharAt(pos);</span><br><span class="line">            pos = Math.max(pos-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos&lt;sb.length()&amp;&amp;sb.charAt(pos)==<span class="string">&#x27;0&#x27;</span>) pos++;</span><br><span class="line">        <span class="keyword">if</span>(pos==sb.length()) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> sb.substring(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC8-字符串转换整数-atoi-Medium"><a href="#LC8-字符串转换整数-atoi-Medium" class="headerlink" title="LC8 字符串转换整数 (atoi) [Medium]"></a>LC8 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">字符串转换整数 (atoi)</a> [Medium]</h3><p>请你来实现一个&nbsp;<code>myAtoi(string s)</code>&nbsp;函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>

<p>函数&nbsp;<code>myAtoi(string s)</code> 的算法如下：</p>

<ol>
    <li>读入字符串并丢弃无用的前导空格</li>
    <li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
    <li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
    <li>将前面步骤读入的这些数字转换为整数（即，"123" -&gt; 123， "0032" -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
    <li>如果整数数超过 32 位有符号整数范围 <code>[−2<sup>31</sup>,&nbsp; 2<sup>31&nbsp;</sup>− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2<sup>31</sup></code> 的整数应该被固定为 <code>−2<sup>31</sup></code> ，大于 <code>2<sup>31&nbsp;</sup>− 1</code> 的整数应该被固定为 <code>2<sup>31&nbsp;</sup>− 1</code> 。</li>
    <li>返回整数作为最终结果。</li>
</ol>

<p><strong>注意：</strong></p>

<ul>
    <li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li>
    <li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1：</strong></p>

<pre>
<strong>输入：</strong>s = "42"
<strong>输出：</strong>42
<strong>解释：</strong>加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："<u>42</u>"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 42 。</pre>

<p><strong>示例&nbsp;2：</strong></p>

<pre>
<strong>输入：</strong>s = "   -42"
<strong>输出：</strong>-42
<strong>解释：</strong>
第 1 步："<u><strong>   </strong></u>-42"（读入前导空格，但忽视掉）
            ^
第 2 步："   <u><strong>-</strong></u>42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   <u><strong>-42</strong></u>"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 -42 。
</pre>

<p><strong>示例&nbsp;3：</strong></p>

<pre>
<strong>输入：</strong>s = "4193 with words"
<strong>输出：</strong>4193
<strong>解释：</strong>
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："<u>4193</u> with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-2<sup>31</sup>, 2<sup>31</sup> - 1] 内，最终结果为 4193 。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= s.length &lt;= 200</code></li>
    <li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>
</ul>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>构造有限状态机</p>
<p><img src="https://gitee.com/ji-ce-xiang/blog-image/raw/master/image-20220501001509062.png" alt="image-20220501001509062"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isPositive = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">switch</span>(state)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>: state=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                            isPositive=<span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                            state=<span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">if</span>(Character.isDigit(c)) &#123;</span><br><span class="line">                                n=readNumber(n,c,isPositive);</span><br><span class="line">                                state=<span class="number">2</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> state=<span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span>(Character.isDigit(c)) &#123;</span><br><span class="line">                        state=<span class="number">2</span>;</span><br><span class="line">                        n=readNumber(n,c,isPositive);</span><br><span class="line">                    &#125;<span class="keyword">else</span> state=<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isPositive) n*=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readNumber</span><span class="params">(<span class="keyword">long</span> n,<span class="keyword">char</span> c,<span class="keyword">boolean</span> isPositive)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==Integer.MAX_VALUE||n==Integer.MIN_VALUE) <span class="keyword">return</span> n;</span><br><span class="line">        n = n*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(isPositive&amp;&amp;n&gt;(<span class="keyword">long</span>)Integer.MAX_VALUE) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(!isPositive&amp;&amp;-n&lt;(<span class="keyword">long</span>)Integer.MIN_VALUE) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC393-UTF-8-编码验证-Medium"><a href="#LC393-UTF-8-编码验证-Medium" class="headerlink" title="LC393 UTF-8 编码验证 [Medium]"></a>LC393 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/utf-8-validation/">UTF-8 编码验证</a> [Medium]</h3><p>给定一个表示数据的整数数组&nbsp;<code>data</code>&nbsp;，返回它是否为有效的 <strong>UTF-8</strong> 编码。</p>

<p><strong>UTF-8</strong> 中的一个字符可能的长度为 <strong>1 到 4 字节</strong>，遵循以下的规则：</p>

<ol>
    <li>对于 <strong>1 字节</strong>&nbsp;的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。</li>
    <li>对于 <strong>n 字节</strong>&nbsp;的字符 (n &gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。</li>
</ol>

<p>这是 UTF-8 编码的工作方式：</p>

<pre>
<code>      </code>Number of Bytes<code>  |        UTF-8 octet sequence
                       |              (binary)
   --------------------+---------------------------------------------
            1          | 0xxxxxxx
            2          | 110xxxxx 10xxxxxx
            3          | 1110xxxx 10xxxxxx 10xxxxxx
            4          | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</code></pre>

<p><code>x</code>&nbsp;表示二进制形式的一位，可以是 <code>0</code>&nbsp;或 <code>1</code>。</p>

<p><strong>注意：</strong>输入是整数数组。只有每个整数的 <strong>最低 8 个有效位</strong> 用来存储数据。这意味着每个整数只表示 1 字节的数据。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>data = [197,130,1]
<strong>输出：</strong>true
<strong>解释：</strong>数据表示字节序列:<strong>11000101 10000010 00000001</strong>。
这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>data = [235,140,4]
<strong>输出：</strong>false
<strong>解释：</strong>数据表示 8 位的序列: <strong>11101011 10001100 00000100</strong>.
前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。
下一个字节是开头为 10 的延续字节，这是正确的。
但第二个延续字节不以 10 开头，所以是不符合规则的。
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= data.length &lt;= 2 * 10<sup>4</sup></code></li>
    <li><code>0 &lt;= data[i] &lt;= 255</code></li>
</ul>

<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>为 <code>0xxxxxxx</code> 、<code>10xxxxxx</code> 、<code>110xxxxx</code>、<code>1110xxxx</code>、<code>11110xxxx</code> 分别分类编码为1~5，其他位模式为6.</p>
<p>根据有限状态机的思想绘制DFA，每个状态接收上述的6类位模式的一种后做状态转移。出现无法接收或者最终状态不是0时表明不是UTF-8编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validUtf8</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Integer num : data)&#123;</span><br><span class="line">            <span class="keyword">int</span>  c = classify(num);</span><br><span class="line">            <span class="keyword">switch</span>(state)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>: state=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">4</span>: state=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">5</span>: state=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>: state=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>: state=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:state=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:state=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:state=<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:state=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">classify</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">0x80</span>)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">0xC0</span>)==<span class="number">0x80</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">0xE0</span>)==<span class="number">0xC0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">0xF0</span>)==<span class="number">0xE0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">0xF8</span>)==<span class="number">0xF0</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC437-路径总和-III-Medium"><a href="#LC437-路径总和-III-Medium" class="headerlink" title="*LC437 路径总和 III [Medium]"></a>*LC437 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">路径总和 III</a> [Medium]</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>相用一个递归函数来匹配以当前结点为起点的路径和为targetSum的路径数量</p>
<p>再用另一个递归函数来移动路径的起点。</p>
<p>注意dfs的递归结束条件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum)</span><br><span class="line">                +pathSum(root.left,targetSum)</span><br><span class="line">                +pathSum(root.right,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val==sum) cnt++; <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)cnt+=dfs(root.left,sum-root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)cnt+=dfs(root.right,sum-root.val);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC464-我能赢吗-Medium"><a href="#LC464-我能赢吗-Medium" class="headerlink" title="*LC464 我能赢吗 [Medium]"></a>*LC464 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-i-win/">我能赢吗</a> [Medium]</h3><p>在 "100 game" 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong>&nbsp; 100 的玩家，即为胜者。</p>

<p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？</p>

<p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p>

<p>给定两个整数&nbsp;<code>maxChoosableInteger</code>&nbsp;（整数池中可选择的最大数）和&nbsp;<code>desiredTotal</code>（累计和），若先出手的玩家是否能稳赢则返回 <code>true</code>&nbsp;，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>maxChoosableInteger = 10, desiredTotal = 11
<strong>输出：</strong>false
<strong>解释：
</strong>无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。
</pre>

<p><strong>示例 2:</strong></p>

<pre>
<b>输入：</b>maxChoosableInteger = 10, desiredTotal = 0
<b>输出：</b>true
</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入：</strong>maxChoosableInteger = 10, desiredTotal = 1
<strong>输出：</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul>
    <li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li>
    <li><code>0 &lt;= desiredTotal &lt;= 300</code></li>
</ul>

<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>用位模式表示各个数字是否被选中，每个位模式构成一个状态，在每个状态下都有一个特定的局面（必胜或必败）。每个状态能扩展的出的子结点就是位模式中的0位所扩展出来的状态。</p>
<ul>
<li>如果当前状态的子结点全是必胜局，则当前状态必败</li>
<li>如果当前状态的子结点存在必败局，则当前状态必胜</li>
</ul>
<p>用DFS和状态DP的组合避免重复搜索同一状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] dp ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxChoosableInteger&gt;=desiredTotal) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxChoosableInteger*(maxChoosableInteger+<span class="number">1</span>)&lt;desiredTotal*<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>&lt;&lt;maxChoosableInteger];</span><br><span class="line">        Arrays.fill(dp,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,desiredTotal,maxChoosableInteger)==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> state,<span class="keyword">int</span> total,<span class="keyword">int</span> maxChoosableInteger)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[state]!=-<span class="number">1</span>) <span class="keyword">return</span> dp[state];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxChoosableInteger;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">1</span>&lt;&lt;(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((cur&amp;state)==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=total || dfs(cur|state,total-i,maxChoosableInteger)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> dp[state]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[state]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC190-颠倒二进制位-Easy"><a href="#LC190-颠倒二进制位-Easy" class="headerlink" title="LC190 颠倒二进制位 [Easy]"></a>LC190 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">颠倒二进制位</a> [Easy]</h3><p>颠倒给定的 32 位无符号整数的二进制位。</p>

<p><strong>提示：</strong></p>

<ul>
    <li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
    <li>在 Java 中，编译器使用<a href="https://baike.baidu.com/item/二进制补码/5295284" target="_blank">二进制补码</a>记法来表示有符号整数。因此，在 <strong>示例 2</strong>&nbsp;中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>
</ul>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 00000010100101000001111010011100
<strong>输出：</strong>964176192 (00111001011110000010100101000000)
<strong>解释：</strong>输入的二进制串 <strong>00000010100101000001111010011100 </strong>表示无符号整数<strong> 43261596</strong><strong>，
    </strong> 因此返回 964176192，其二进制表示形式为 <strong>00111001011110000010100101000000</strong>。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 11111111111111111111111111111101
<strong>输出：</strong>3221225471 (10111111111111111111111111111111)
<strong>解释：</strong>输入的二进制串 <strong>11111111111111111111111111111101</strong> 表示无符号整数 4294967293，
   &nbsp; 因此返回 3221225471 其二进制表示形式为 <strong>10111111111111111111111111111111 。</strong></pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>输入是一个长度为 <code>32</code> 的二进制字符串</li>
</ul>
<p><strong>进阶</strong>: 如果多次调用这个函数，你将如何优化你的算法？</p>

<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>位运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            m &lt;&lt;=<span class="number">1</span> ;</span><br><span class="line">            m |= (n&amp;<span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LC384-打乱数组-Medium"><a href="#LC384-打乱数组-Medium" class="headerlink" title="LC384 打乱数组 [Medium]"></a>LC384 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-an-array/">打乱数组</a> [Medium]</h3><p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是&nbsp;<strong>等可能</strong>&nbsp;的。</p>

<p>实现 <code>Solution</code> class:</p>

<ul>
    <li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li>
    <li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li>
    <li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li>
</ul>
<p><strong>示例 1：</strong></p>

<pre>
<strong>输入</strong>
["Solution", "shuffle", "reset", "shuffle"]
[[[1, 2, 3]], [], [], []]
<strong>输出</strong>
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]
<strong>解释</strong>
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]
solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]
solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]
</pre>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= nums.length &lt;= 50</code></li>
    <li><code>-10<sup>6</sup> &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>
    <li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li>
    <li>最多可以调用 <code>10<sup>4</sup></code> 次 <code>reset</code> 和 <code>shuffle</code></li>
</ul>

<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先生成一个数组flag[i]，表示新数组中第i个元素对应原数组第flag[i]个元素。</p>
<p>生成的过程是循环产生随机数知道flag[r]为空(即为-1)。时间复杂度 $O(n^2)$ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] orgNums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] shuffledNums;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        orgNums = nums.clone();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> orgNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] place(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span> [] flag = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        Arrays.fill(flag,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r ;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                r = (random.nextInt()%n+n)%n;</span><br><span class="line">            &#125;<span class="keyword">while</span>(flag[r]!=-<span class="number">1</span>);</span><br><span class="line">            flag[r] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">int</span> n = orgNums.length;</span><br><span class="line">        <span class="keyword">int</span> [] places = place(n);</span><br><span class="line">        shuffledNums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            shuffledNums[i]=orgNums[places[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shuffledNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路二-Fisher-Yates-洗牌算法"><a href="#思路二-Fisher-Yates-洗牌算法" class="headerlink" title="* 思路二 Fisher-Yates 洗牌算法"></a>* 思路二 Fisher-Yates 洗牌算法</h4><p><img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20220425144713404.png" alt="image-20220425144713404"></p>
<p>时间复杂度 $O(n)$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] orgNums;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] shuffledNums;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        orgNums = nums.clone();</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> orgNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">int</span> n = orgNums.length;</span><br><span class="line">        shuffledNums = orgNums.clone();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = (random.nextInt()%n+n)%n;</span><br><span class="line">            <span class="keyword">int</span> t = shuffledNums[r];</span><br><span class="line">            shuffledNums[r] = shuffledNums[n-<span class="number">1</span>];</span><br><span class="line">            shuffledNums[n-<span class="number">1</span>] = t;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shuffledNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="LC172-阶乘后的零-Medium"><a href="#LC172-阶乘后的零-Medium" class="headerlink" title="LC172 阶乘后的零[Medium]"></a>LC172 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">阶乘后的零</a>[Medium]</h3><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。</p>
<p>$0\le n \le 10^4$</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>利用结论，在[1,n]之间所有整数包含的质因子p的个数为</p>
<p><img src="https://gitee.com/ji-ce-xiang/blog-image/raw/master/image-20220425142230386.png" alt="image-20220425142230386"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> twoCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fiveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">            twoCount += n/t;</span><br><span class="line">            t&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t =<span class="number">5</span> ;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;=n)&#123;</span><br><span class="line">            fiveCount += n/t;</span><br><span class="line">            t *=<span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(fiveCount,twoCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC958-二叉树的完全性检验-Medium"><a href="#LC958-二叉树的完全性检验-Medium" class="headerlink" title="LC958 二叉树的完全性检验 [Medium]"></a>LC958 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">二叉树的完全性检验</a> [Medium]</h3><p>给定一个二叉树的<meta charset="UTF-8" />&nbsp;<code>root</code>&nbsp;，确定它是否是一个&nbsp;<em>完全二叉树</em>&nbsp;。</p>

<p>在一个&nbsp;<strong><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin" target="_blank">完全二叉树</a></strong>&nbsp;中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含<meta charset="UTF-8" />&nbsp;<code>1</code>&nbsp;到<meta charset="UTF-8" />&nbsp;<code>2<sup>h</sup></code>&nbsp;节点之间的最后一级 <code>h</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-1.png" /></p>

<pre>
<strong>输入：</strong>root = [1,2,3,4,5,6]
<strong>输出：</strong>true
<strong>解释：</strong>最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
</pre>

<p><strong>示例 2：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/complete-binary-tree-2.png" /></strong></p>

<pre>
<strong>输入：</strong>root = [1,2,3,4,5,null,7]
<strong>输出：</strong>false
<strong>解释：</strong>值为 7 的结点没有尽可能靠向左侧。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>树的结点数在范围 <meta charset="UTF-8" />&nbsp;<code>[1, 100]</code>&nbsp;内。</li>
    <li><code>1 &lt;= Node.val &lt;= 1000</code></li>
</ul>

<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>利用完全二叉树的性质，从0开始编号，如果为根节点编号为i，则左子结点编号为$2<em>i+1$ ，右子结点编号为$2</em>i+2$ 。遍历整棵树，将结点值根据编号值放在数组里。从左到右遍历这个数组，如果数组中没有间断，就表明它是完全二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] nums ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nodeCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">105</span>];</span><br><span class="line">        Arrays.fill(nums,-<span class="number">1</span>);</span><br><span class="line">        nodeCount=<span class="number">0</span>;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodeCount;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root ,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=<span class="number">105</span>) &#123;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index]=root.val;</span><br><span class="line">        nodeCount++;</span><br><span class="line">        dfs(root.left,index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        dfs(root.right,index*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC1367-二叉树中的列表-Medium"><a href="#LC1367-二叉树中的列表-Medium" class="headerlink" title="LC1367 二叉树中的列表 [Medium]"></a>LC1367 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/">二叉树中的列表</a> [Medium]</h3><p>给你一棵以&nbsp;<code>root</code>&nbsp;为根的二叉树和一个&nbsp;<code>head</code>&nbsp;为第一个节点的链表。</p>

<p>如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以&nbsp;<code>head</code>&nbsp;为首的链表中每个节点的值，那么请你返回 <code>True</code> ，否则返回 <code>False</code> 。</p>

<p>一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_1_1720.png" style="height: 280px; width: 220px;"></strong></p>

<pre><strong>输入：</strong>head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>输出：</strong>true
<strong>解释：</strong>树中蓝色的节点构成了与链表对应的子路径。
</pre>

<p><strong>示例 2：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/sample_2_1720.png" style="height: 280px; width: 220px;"></strong></p>

<pre><strong>输入：</strong>head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>输出：</strong>true
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
<strong>输出：</strong>false
<strong>解释：</strong>二叉树中不存在一一对应链表的路径。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>二叉树和链表中的每个节点的值都满足&nbsp;<code>1 &lt;= node.val&nbsp;&lt;= 100</code>&nbsp;。</li>
    <li>链表包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>100</code>&nbsp;之间。</li>
    <li>二叉树包含的节点数目在&nbsp;<code>1</code>&nbsp;到&nbsp;<code>2500</code>&nbsp;之间。</li>
</ul>

<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>采用递归的思想。分两步：首先，我们找到固定以root为head的起点做逐一匹配的方法isMatched；然后，我们再编写树的匹配起点不固定的情况下查找匹配的方法isSubPath。两个过程都借助递归来实现，都先假设左右子树已经做好类似的处理，我们再处理根结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>&amp;&amp;root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(isMatched(head,root)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubPath(head,root.left) | isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatched</span><span class="params">(ListNode head,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val==root.val)</span><br><span class="line">            <span class="keyword">return</span> isMatched(head.next,root.left)</span><br><span class="line">                    | isMatched(head.next,root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="剑指offer36-LC426-将二叉搜索树转化为排序的双向链表-Medium"><a href="#剑指offer36-LC426-将二叉搜索树转化为排序的双向链表-Medium" class="headerlink" title="剑指offer36/LC426 将二叉搜索树转化为排序的双向链表 [Medium]"></a>剑指offer36/LC426 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">将二叉搜索树转化为排序的双向链表</a> [Medium]</h3><p>将一个 <strong>二叉搜索树</strong> 就地转化为一个 <strong>已排序的双向循环链表</strong> 。</p>

<p>对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>

<p>特别地，我们希望可以 <strong>就地</strong> 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>root = [4,2,5,1,3] 
<img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" style="width: 400px;" />
<strong>输出：</strong>[1,2,3,4,5]

<strong>解释：</strong>下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。
<img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png" style="width: 400px;" />
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>[1,2,3]
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>root = []
<strong>输出：</strong>[]
<strong>解释：</strong>输入是空树，所以输出也是空链表。
</pre>

<p><strong>示例 4：</strong></p>

<pre>
<strong>输入：</strong>root = [1]
<strong>输出：</strong>[1]
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>-1000 <= Node.val <= 1000</code></li>
    <li><code>Node.left.val < Node.val < Node.right.val</code></li>
    <li><code>Node.val</code> 的所有值都是独一无二的</li>
    <li><code>0 <= Number of Nodes <= 2000</code></li>
</ul>

<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>对于BST的某个子树的根结点root，我们先找到它的前驱结点l和后继结点r。然后对左右子树递归处理，递归处理后可以认为左右子树都已经形成链表结构。随后将l、root、r相互连接。最后在顺序遍历链表，找到整个链表的首尾连接起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        root = transfer(root);</span><br><span class="line">        Node head = root;</span><br><span class="line">        Node tail = root;</span><br><span class="line">        <span class="keyword">while</span>(head.left!=<span class="keyword">null</span>) head=head.left;</span><br><span class="line">        <span class="keyword">while</span>(tail.right!=<span class="keyword">null</span>) tail=tail.right;</span><br><span class="line">        tail.right=head;</span><br><span class="line">        head.left=tail;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findPrecursor</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root.left==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node p = root.left;</span><br><span class="line">        <span class="keyword">while</span>(p.right!=<span class="keyword">null</span>) p=p.right;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findSuccessor</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root.right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node p = root.right;</span><br><span class="line">        <span class="keyword">while</span>(p.left!=<span class="keyword">null</span>) p=p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">transfer</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node l = findPrecursor(root);</span><br><span class="line">        Node r = findSuccessor(root);</span><br><span class="line">        transfer(root.left);</span><br><span class="line">        transfer(root.right);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="keyword">null</span>)l.right=root;</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="keyword">null</span>)r.left=root;</span><br><span class="line">        root.left=l;</span><br><span class="line">        root.right=r;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-求解整数区间-1-n-中所有整数包含质因子p的个数"><a href="#1-求解整数区间-1-n-中所有整数包含质因子p的个数" class="headerlink" title="1.求解整数区间[1,n] 中所有整数包含质因子p的个数"></a>1.求解整数区间[1,n] 中所有整数包含质因子p的个数</h3><p><img src="https://gitee.com/ji-ce-xiang/blog-image/raw/master/image-20220425142230386.png" alt="image-20220425142230386"></p>
<p>例题见LC1172</p>
<h3 id="2-Fisher-Yates-洗牌算法"><a href="#2-Fisher-Yates-洗牌算法" class="headerlink" title="2.Fisher-Yates 洗牌算法"></a>2.Fisher-Yates 洗牌算法</h3><p><img src="C:/Users/DELL/AppData/Roaming/Typora/typora-user-images/image-20220425144707425.png" alt="image-20220425144707425"></p>
<h3 id="3-考察树的递归性质，两个递归函数来做匹配"><a href="#3-考察树的递归性质，两个递归函数来做匹配" class="headerlink" title="3.考察树的递归性质，两个递归函数来做匹配"></a>3.考察树的递归性质，两个递归函数来做匹配</h3><p>寻找树中自上而下的一条连续路径的某个性质，如和某个序列匹配、或者和为多少等，都可以写两个递归函数来实现，第一个递归函数先假设以root为根结点的子树就是符合要求的开始匹配，第二个递归函数对根结点、左右子树分别调用第一个递归函数。</p>
<p>LC1367  LC437</p>
<h3 id="4-有限状态机解决解析字符串的问题"><a href="#4-有限状态机解决解析字符串的问题" class="headerlink" title="4.有限状态机解决解析字符串的问题"></a>4.有限状态机解决解析字符串的问题</h3><p>LC393  LC8</p>
<h3 id="5-单调栈解决删除序列中部分元素得到最小序问题"><a href="#5-单调栈解决删除序列中部分元素得到最小序问题" class="headerlink" title="5.单调栈解决删除序列中部分元素得到最小序问题"></a>5.单调栈解决删除序列中部分元素得到最小序问题</h3><p>该类问题往往对单调栈做出额外的限制，如要求同值的元素最多出栈若干次，入栈时栈内不能有相同值的元素</p>
<p>LC402 LC1081</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张海达</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://no-existence.github.io/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/">https://no-existence.github.io/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://no-existence.github.io" target="_blank">Insular Oasis</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/Leetcode.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/8.%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"><img class="prev-cover" src="/img/cover/CSAPP.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSAPP 8 异常控制流</div></div></a></div><div class="next-post pull-right"><a href="/6.%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"><img class="next-cover" src="/img/cover/CSAPP.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSAPP 6 存储器层次结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/3-1快速排序及优化/" title="Leetcode 快速排序联系"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-19</div><div class="title">Leetcode 快速排序联系</div></div></a></div><div><a href="/3-4拓扑排序/" title="Leetcode 拓扑排序练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">Leetcode 拓扑排序练习</div></div></a></div><div><a href="/3-3不基于比较的排序/" title="Leetcode 不基于比较的排序的练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-05</div><div class="title">Leetcode 不基于比较的排序的练习</div></div></a></div><div><a href="/4-3 深搜与广搜/" title="Leetcode 深搜广搜练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-10</div><div class="title">Leetcode 深搜广搜练习</div></div></a></div><div><a href="/1-2 线程池与任务队列/" title="Leetcode 队列练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="title">Leetcode 队列练习</div></div></a></div><div><a href="/1-1 链表及经典问题/" title="Leetcode 链表练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-19</div><div class="title">Leetcode 链表练习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">张海达</div><div class="author-info__description">张海达的个人博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/No-Existence"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/No-Existence" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5-3"><span class="toc-number">1.</span> <span class="toc-text">5-3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LC1081-316-%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97-Medium"><span class="toc-number">1.0.1.</span> <span class="toc-text">*LC1081&#x2F;316 不同字符的最小子序列 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97-Medium"><span class="toc-number">1.0.2.</span> <span class="toc-text">* LC402 移掉 K 位数字 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi-Medium"><span class="toc-number">1.0.3.</span> <span class="toc-text">LC8 字符串转换整数 (atoi) [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC393-UTF-8-%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81-Medium"><span class="toc-number">1.0.4.</span> <span class="toc-text">LC393 UTF-8 编码验证 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-III-Medium"><span class="toc-number">1.0.5.</span> <span class="toc-text">*LC437 路径总和 III [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97-Medium"><span class="toc-number">1.0.6.</span> <span class="toc-text">*LC464 我能赢吗 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D-Easy"><span class="toc-number">1.0.7.</span> <span class="toc-text">LC190 颠倒二进制位 [Easy]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC384-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84-Medium"><span class="toc-number">1.0.8.</span> <span class="toc-text">LC384 打乱数组 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C-Fisher-Yates-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">* 思路二 Fisher-Yates 洗牌算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-Medium"><span class="toc-number">1.0.9.</span> <span class="toc-text">LC172 阶乘后的零[Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC958-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C-Medium"><span class="toc-number">1.0.10.</span> <span class="toc-text">LC958 二叉树的完全性检验 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC1367-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8-Medium"><span class="toc-number">1.0.11.</span> <span class="toc-text">LC1367 二叉树中的列表 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer36-LC426-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-Medium"><span class="toc-number">1.0.12.</span> <span class="toc-text">剑指offer36&#x2F;LC426 将二叉搜索树转化为排序的双向链表 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B1%82%E8%A7%A3%E6%95%B4%E6%95%B0%E5%8C%BA%E9%97%B4-1-n-%E4%B8%AD%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E5%8C%85%E5%90%AB%E8%B4%A8%E5%9B%A0%E5%AD%90p%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.求解整数区间[1,n] 中所有整数包含质因子p的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Fisher-Yates-%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Fisher-Yates 洗牌算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%80%83%E5%AF%9F%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E6%80%A7%E8%B4%A8%EF%BC%8C%E4%B8%A4%E4%B8%AA%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E6%9D%A5%E5%81%9A%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.考察树的递归性质，两个递归函数来做匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E8%A7%A3%E5%86%B3%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.有限状态机解决解析字符串的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8D%95%E8%B0%83%E6%A0%88%E8%A7%A3%E5%86%B3%E5%88%A0%E9%99%A4%E5%BA%8F%E5%88%97%E4%B8%AD%E9%83%A8%E5%88%86%E5%85%83%E7%B4%A0%E5%BE%97%E5%88%B0%E6%9C%80%E5%B0%8F%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.单调栈解决删除序列中部分元素得到最小序问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8.%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP 8 异常控制流"><img src="/img/cover/CSAPP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP 8 异常控制流"/></a><div class="content"><a class="title" href="/8.%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP 8 异常控制流">CSAPP 8 异常控制流</a><time datetime="2022-05-05T06:43:22.000Z" title="发表于 2022-05-05 14:43:22">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" title="Leetcode 练习"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 练习"/></a><div class="content"><a class="title" href="/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" title="Leetcode 练习">Leetcode 练习</a><time datetime="2022-05-02T09:11:01.000Z" title="发表于 2022-05-02 17:11:01">2022-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6.%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="CSAPP 6 存储器层次结构"><img src="/img/cover/CSAPP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP 6 存储器层次结构"/></a><div class="content"><a class="title" href="/6.%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="CSAPP 6 存储器层次结构">CSAPP 6 存储器层次结构</a><time datetime="2022-04-30T08:36:12.000Z" title="发表于 2022-04-30 16:36:12">2022-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5-2%20%E5%8D%95%E8%B0%83%E6%A0%88/" title="Leetcode 单调栈练习"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 单调栈练习"/></a><div class="content"><a class="title" href="/5-2%20%E5%8D%95%E8%B0%83%E6%A0%88/" title="Leetcode 单调栈练习">Leetcode 单调栈练习</a><time datetime="2022-04-29T11:30:01.000Z" title="发表于 2022-04-29 19:30:01">2022-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5-1%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="Leetcode 单调队列练习"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 单调队列练习"/></a><div class="content"><a class="title" href="/5-1%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="Leetcode 单调队列练习">Leetcode 单调队列练习</a><time datetime="2022-04-25T04:20:01.000Z" title="发表于 2022-04-25 12:20:01">2022-04-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 张海达</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>