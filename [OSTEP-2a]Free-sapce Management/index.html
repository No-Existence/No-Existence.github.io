<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Insular Oasis | Insular Oasis</title><meta name="author" content="张海达"><meta name="copyright" content="张海达"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态内存分配：malloc 和 free 的实现项目要求In this project, you will be implementing a memory allocator for the heap of a user-level process. Your functions will be to build your own malloc() and free(). Memory allo">
<meta property="og:type" content="article">
<meta property="og:title" content="Insular Oasis">
<meta property="og:url" content="https://no-existence.github.io/[OSTEP-2a]Free-sapce%20Management/index.html">
<meta property="og:site_name" content="Insular Oasis">
<meta property="og:description" content="动态内存分配：malloc 和 free 的实现项目要求In this project, you will be implementing a memory allocator for the heap of a user-level process. Your functions will be to build your own malloc() and free(). Memory allo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://no-existence.github.io/img/cover.jpg">
<meta property="article:published_time" content="2021-10-24T04:11:33.004Z">
<meta property="article:modified_time" content="2021-10-24T04:30:22.132Z">
<meta property="article:author" content="张海达">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://no-existence.github.io/img/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://no-existence.github.io/[OSTEP-2a]Free-sapce%20Management/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Insular Oasis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-24 12:30:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Insular Oasis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-24T04:11:33.004Z" title="发表于 2021-10-24 12:11:33">2021-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-24T04:30:22.132Z" title="更新于 2021-10-24 12:30:22">2021-10-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="动态内存分配：malloc-和-free-的实现"><a href="#动态内存分配：malloc-和-free-的实现" class="headerlink" title="动态内存分配：malloc 和 free 的实现"></a>动态内存分配：malloc 和 free 的实现</h1><h2 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h2><p>In this project, you will be implementing a memory allocator for the heap of a user-level process. Your functions will be to build your own malloc() and free().</p>
<p>Memory allocators have two distinct tasks. First, the memory allocator asks the operating system to expand the heap portion of the process’s address space by calling either sbrk or mmap. Second, the memory allocator doles out this memory to the calling process. This involves managing a free list of memory and finding a contiguous chunk of memory that is large enough for the user’s request; when the user later frees memory, it is added back to this list.</p>
<p>This memory allocator is usually provided as part of a standard library and is not part of the OS. To be clear, the memory allocator operates entirely within the virtual address space of a single process and knows nothing about which physical pages have been allocated to this process or the mapping from logical addresses to physical addresses; that part is handled by the operating system.</p>
<p>When implementing this basic functionality in your project, we have a few guidelines. First, when requesting memory from the OS, you must use <strong>mmap()</strong> (which is easier to use than sbrk()). Second, although a real memory allocator requests more memory from the OS whenever it can’t satisfy a request from the user, your memory allocator must call mmap() only <strong>one</strong> time (when it is first initialized).</p>
<p>Classic malloc() and free() are defined as follows:</p>
<ul>
<li><code>void *malloc(size_t size)</code>, which allocates size bytes and returns a pointer to the allocated memory. The memory is not cleared.</li>
<li><code>void free(void *ptr)</code>, which frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc() (or calloc() or realloc()). Otherwise, or if free(ptr) has already been called before, undefined behaviour occurs. If ptr is NULL, no operation is performed.</li>
</ul>
<p>For simplicity, your implementations of <code>mem_alloc()</code> and <code>mem_free()</code> should basically follow what malloc() and free() do; see below for details.</p>
<p>You will also provide a supporting function, <code>mem_dump()</code>, described below; this routine simply prints which regions are currently free and should be used by you for debugging purposes.</p>
<p>For this project, you will be implementing several different routines as part of a shared library. Note that you will not be writing a main() routine for the code that you handin (but you should implement one for your own testing). We have provided the prototypes for these functions in the file <a href="../src/mem.h">mem.h</a>;  you should include this header file in your code to ensure that you are adhering to the specification exactly. <strong>You should not change mem.h in any way!</strong> We now define each of these routines more precisely.</p>
<ul>
<li><p><code>int mem_init(int size_of_region)</code>: mem_init is called one time by a process using your routines. <code>size_of_region</code> is the number of bytes that you should request from the OS using mmap().</p>
<p>Note that you may need to round up this amount so that you request memory in units of the page size (see the man pages for <code>getpagesize()</code>). Note also that you need to use this allocated memory for your own data structures as well; that is, your infrastructure for tracking the mapping from addresses to memory objects has to be placed in this region as well. You are <strong>not</strong> allowed to malloc(), or any other related function, in any of your routines! Similarly, you should <strong>not</strong> allocate global arrays. However, you may allocate a few global variables (e.g., a pointer to the head of your free list.)</p>
<p>Return 0 on a success (when call to mmap is successful). Otherwise, return -1 and set <code>m_error</code> to <code>E_BAD_ARGS</code>. Cases where mem_init should return a failure: mem_init is called more than once; size_of_region is less than or equal to 0.</p>
</li>
<li><p><code>void *mem_alloc(int size, int style)</code>: mem_alloc is similar to the library function malloc(). mem_alloc takes as input the size in bytes of the object to be allocated and returns a pointer to the start of that object. The function returns NULL if there is not enough contiguous free space within <code>size_of_region</code> allocated by mem_init to satisfy this request (and sets <code>m_error</code> to <code>E_NO_SPACE</code>).</p>
<p>The style parameter determines how to look through the list for a free space. It can be set to <code>M_BESTFIT</code> (BF) for the best-fit policy, <code>M_WORSTFIT</code> (WF) for worst-fit, and <code>M_FIRSTFIT</code> (FF) for first-fit. BF simply looks through your free list and finds the first free space that is smallest in size (but still can hold the requested amount) and returns the requested size (the first part of the chunk) to the user, keeping the rest of the chunk in its free list; WF looks for the largest chunk and allocates the requested space out of that; FF looks for the first chunk that fits and returns the requested space out of that.</p>
<p>For performance reasons, <code>mem_alloc()</code> should return 8-byte aligned chunks of memory. For example if a user allocates 1 byte of memory, your <code>mem_alloc()</code> implementation should return 8 bytes of memory so that the next free block will be 8-byte alligned too. To figure out whether you return 8-byte aligned pointers, you could print the pointer this way <code>printf(&quot;%p&quot;, ptr)</code>. The last digit should be a multiple of 8 (i.e. 0 or 8).</p>
</li>
<li><p><code>int mem_free(void *ptr)</code>: mem_free() frees the memory object that ptr points to. Just like with the standard free(), if ptr is NULL, then no operation is performed. The function returns 0 on success, and -1 otherwise.</p>
<p><strong>Coalescing</strong>: mem_free() should make sure to coalesce free space. Coalescing rejoins neighboring freed blocks into one bigger free chunk, thus ensuring that big chunks remain free for subsequent calls to mem_alloc().</p>
</li>
<li><p><code>void mem_dump()</code>: This is just a debugging routine for your own use. Have it print the regions of free memory to the screen.</p>
</li>
</ul>
<p>简而言之，实现动态内存分配malloc和free的功能，并满足如下几个要求：</p>
<ul>
<li>要求使用mmap来申请一个内存空间（大小必须为页大小的倍数），且只能申请一次。</li>
<li>不允许使用全局数组，但可以使用少量的全局变量如链表的头指针，也就是说，不记mmap申请的内存开销，空间复杂度不能超过O(1)。</li>
<li> 实现mem_alloc函数时要实现最佳匹配、最差匹配和首次适应这三种算法。</li>
<li>实现mem_free函数时要做相邻空闲块的合并(即 coalescing)</li>
<li>注意字节对齐以及异常处理等细节</li>
</ul>
<p>给出的<code>mem.h</code>头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MEM_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MEM_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_NO_SPACE            1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_CORRUPT_FREESPACE   2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_PADDING_OVERWRITTEN 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_BAD_ARGS            4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_BAD_POINTER         5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_BESTFIT   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_WORSTFIT  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_FIRSTFIT  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> m_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">int</span> size_of_region)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mem_alloc</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> style)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem_free</span><span class="params">(<span class="keyword">void</span> * ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_dump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路参考 <code>OSTEP 第十七章 空闲内存管理</code> </p>
<ul>
<li>用链表来组织所有的空闲块</li>
<li>分配空闲块时根据给定的算法找到大小合适的空闲块，<strong>从空闲块的尾部开始分配空间</strong>（这也可以避免当前空闲块的地址改变，重新在链表中查找并修改前驱结点的next）</li>
<li>释放空间时，需要确定前后内存块是否空闲<ul>
<li>为确定前一个内存块是否空闲，我们遍历空闲块链表，计算每个空闲块的下一个块的地址是否与当前块的地址相同。如果遍历完后没有找到，表明前一内存块已分配，不用合并；否则将当前块与找到的空闲块合并，只需修改找到的空闲块的size而无需在链表中新增结点。</li>
<li>为确定后一个内存块是否空闲，我们先计算当前块的下一内存块的地址，再遍历空闲块链表，找下一内存块的地址是否在空闲块链表里。如果下一块内存块空闲，则做合并，让合并后的块代替下一个内存块在链表中原来的位置；否则直接用头插法往链表中插入当前块。</li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li><p>mem_struct.h </p>
<p>相关结构体和变量、函数的声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MEMSTRUCT_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MEMSTRUCT_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC 9876</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; <span class="keyword">node_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">header_t</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> magic;</span><br><span class="line">&#125;<span class="keyword">header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deal with the given memory</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> * start_address;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> * end_address;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">round_up_to_page_size</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fit strategy</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">best_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">worst_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">first_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deal with list</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">node_t</span> * head;</span><br><span class="line"><span class="function"><span class="keyword">header_t</span> * <span class="title">alloc_block_in_list</span><span class="params">(<span class="keyword">node_t</span> * fptr,<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">node_t</span> * <span class="title">find_precursor</span><span class="params">(<span class="keyword">node_t</span> * node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node_into_head</span><span class="params">(<span class="keyword">node_t</span> * node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(<span class="keyword">node_t</span> * node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alter_node_address</span><span class="params">(<span class="keyword">node_t</span> * old_addr,<span class="keyword">node_t</span> * new_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>mem.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mem.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mem_struct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m_error;</span><br><span class="line"><span class="keyword">void</span> * start_address;</span><br><span class="line"><span class="keyword">void</span> * end_address;</span><br><span class="line"><span class="keyword">node_t</span> * head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">round_up</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(size%n==<span class="number">0</span>) <span class="keyword">return</span> size;</span><br><span class="line">	<span class="keyword">return</span> (size/n+<span class="number">1</span>)*n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">int</span> size_of_region)</span></span>&#123;</span><br><span class="line">	size_of_region = round_up(size_of_region,getpagesize());</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/zero&quot;</span>, O_RDWR);</span><br><span class="line">	start_address = mmap(<span class="literal">NULL</span>,size_of_region,</span><br><span class="line">			PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE,fd,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(start_address==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		m_error = E_BAD_ARGS;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	end_address=start_address+size_of_region;</span><br><span class="line">	close(fd);</span><br><span class="line">	head=(<span class="keyword">node_t</span> *) start_address;</span><br><span class="line">	head-&gt;size=size_of_region-<span class="keyword">sizeof</span>(<span class="keyword">header_t</span>);</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">mem_alloc</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> style)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	size = round_up(size,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">node_t</span> * fptr ; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(style)&#123;</span><br><span class="line">		<span class="keyword">case</span> M_BESTFIT: fptr=best_fit(size);<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> M_WORSTFIT: fptr=worst_fit(size);<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> M_FIRSTFIT: fptr=first_fit(size);<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(fptr==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		m_error=E_NO_SPACE;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">header_t</span> * uptr = alloc_block_in_list(fptr,size);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span>*)uptr + <span class="keyword">sizeof</span>(<span class="keyword">header_t</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem_free</span><span class="params">(<span class="keyword">void</span> * ptr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// get actual ptr</span></span><br><span class="line">	ptr -= <span class="keyword">sizeof</span>(<span class="keyword">header_t</span>);</span><br><span class="line">	<span class="keyword">header_t</span> * uptr = (<span class="keyword">header_t</span> *) ptr;</span><br><span class="line">	<span class="keyword">node_t</span> * fptr = (<span class="keyword">node_t</span> *) ptr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// test magic number</span></span><br><span class="line">	<span class="keyword">if</span>(uptr-&gt;magic!=MAGIC) &#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;</span><br><span class="line">	uptr-&gt;magic=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// figure out whether pre-block or next block is free</span></span><br><span class="line">	<span class="keyword">int</span> next_is_free=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pre_is_free=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * pre_fptr = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">void</span> * next_ptr = ptr+<span class="keyword">sizeof</span>(<span class="keyword">header_t</span>)+uptr-&gt;size;</span><br><span class="line">	<span class="keyword">node_t</span> * next_fptr= (<span class="keyword">node_t</span> *)next_ptr;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// search the list to figure it out.</span></span><br><span class="line">	<span class="keyword">node_t</span> * p = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">void</span>*)p==next_ptr) next_is_free=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">void</span>*)p+<span class="keyword">sizeof</span>(<span class="keyword">header_t</span>)+p-&gt;size==(<span class="keyword">void</span>*)uptr) pre_is_free=<span class="number">1</span>,pre_fptr=p;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// coalescing</span></span><br><span class="line">	<span class="keyword">if</span>(pre_is_free)&#123;</span><br><span class="line">		pre_fptr-&gt;size += uptr-&gt;size+<span class="keyword">sizeof</span>(<span class="keyword">header_t</span>);</span><br><span class="line">		<span class="keyword">if</span>(next_is_free)&#123;</span><br><span class="line">			pre_fptr-&gt;size += next_fptr-&gt;size+<span class="keyword">sizeof</span>(<span class="keyword">header_t</span>);</span><br><span class="line">			delete_node(next_fptr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(next_is_free)&#123;</span><br><span class="line">		next_fptr-&gt;size += fptr-&gt;size + <span class="keyword">sizeof</span>(<span class="keyword">header_t</span>);</span><br><span class="line">		alter_node_address(next_fptr,fptr);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		insert_node_into_head(fptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">best_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * min_block=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * p=head;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;size&gt;=size)&#123;</span><br><span class="line">			<span class="keyword">if</span>(min_block==<span class="literal">NULL</span>||min_block-&gt;size&gt;p-&gt;size)</span><br><span class="line">				min_block=p;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">worst_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * max_block=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * p=head;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;size&gt;=size)&#123;</span><br><span class="line">			<span class="keyword">if</span>(max_block==<span class="literal">NULL</span>||max_block-&gt;size&gt;p-&gt;size)</span><br><span class="line">				max_block=p;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max_block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">first_fit</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * p=head;</span><br><span class="line">	<span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;size&gt;=size)<span class="keyword">return</span> p;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">header_t</span> * <span class="title">alloc_block_in_list</span><span class="params">(<span class="keyword">node_t</span> * fptr,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">header_t</span> * uptr = (<span class="keyword">header_t</span> *)((<span class="keyword">void</span>*)fptr + fptr-&gt;size - size );</span><br><span class="line">	fptr-&gt;size -= (size+<span class="keyword">sizeof</span>(<span class="keyword">header_t</span>));</span><br><span class="line">	<span class="keyword">if</span>(fptr-&gt;size==<span class="number">0</span>) &#123;</span><br><span class="line">		delete_node(fptr);</span><br><span class="line">	&#125;<span class="comment">//else alter_node_address(fptr, (node_t *)((void*)fptr+size+sizeof(header_t)));</span></span><br><span class="line">	uptr-&gt;size=size;</span><br><span class="line">	uptr-&gt;magic=MAGIC;</span><br><span class="line">	<span class="keyword">return</span> uptr;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">node_t</span> * <span class="title">find_precursor</span><span class="params">(<span class="keyword">node_t</span> * node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>||node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(node==head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">node_t</span> * p=head-&gt;next;</span><br><span class="line">	<span class="keyword">node_t</span> * pre=head;</span><br><span class="line">	<span class="keyword">while</span>(p!=node)&#123;</span><br><span class="line">		pre=p;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node_into_head</span><span class="params">(<span class="keyword">node_t</span> * node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		node-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		head=node;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		node-&gt;next=head;</span><br><span class="line">		head=node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(<span class="keyword">node_t</span> * node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(node==head)&#123;</span><br><span class="line">		head=head-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">node_t</span> * p =find_precursor(node);</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">	p-&gt;next=node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if you just want to modify the starting address of a node, use this function. </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alter_node_address</span><span class="params">(<span class="keyword">node_t</span> * old_addr,<span class="keyword">node_t</span> * new_addr)</span></span>&#123;</span><br><span class="line">	new_addr-&gt;size = old_addr-&gt;size;</span><br><span class="line">	new_addr-&gt;next = old_addr-&gt;next;</span><br><span class="line">	<span class="keyword">node_t</span> * pre_node = find_precursor(old_addr);</span><br><span class="line">	<span class="keyword">if</span>(pre_node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		pre_node-&gt;next=new_addr;</span><br><span class="line">	&#125;<span class="keyword">else</span> head = new_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张海达</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://no-existence.github.io/[OSTEP-2a]Free-sapce%20Management/">https://no-existence.github.io/[OSTEP-2a]Free-sapce%20Management/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://no-existence.github.io" target="_blank">Insular Oasis</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Dubbo/"><img class="prev-cover" src="/img/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Dubbo</div></div></a></div><div class="next-post pull-right"><a href="/%5BOSTEP-1b%5Dxv6%20System%20Call/"><img class="next-cover" src="/img/cover/OSTEP.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OSTEP-Project-1b xv6 System Call</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">张海达</div><div class="author-info__description">张海达的个人博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/No-Existence"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/No-Existence" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9Amalloc-%E5%92%8C-free-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">动态内存分配：malloc 和 free 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">项目要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.</span> <span class="toc-text">项目实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Dubbo/" title="Dubbo"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dubbo"/></a><div class="content"><a class="title" href="/Dubbo/" title="Dubbo">Dubbo</a><time datetime="2022-03-06T07:42:10.000Z" title="发表于 2022-03-06 15:42:10">2022-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%5BOSTEP-2a%5DFree-sapce%20Management/" title="无题"><img src="/img/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/%5BOSTEP-2a%5DFree-sapce%20Management/" title="无题">无题</a><time datetime="2021-10-24T04:11:33.004Z" title="发表于 2021-10-24 12:11:33">2021-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%5BOSTEP-1b%5Dxv6%20System%20Call/" title="OSTEP-Project-1b xv6 System Call"><img src="/img/cover/OSTEP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OSTEP-Project-1b xv6 System Call"/></a><div class="content"><a class="title" href="/%5BOSTEP-1b%5Dxv6%20System%20Call/" title="OSTEP-Project-1b xv6 System Call">OSTEP-Project-1b xv6 System Call</a><time datetime="2021-10-02T12:16:19.000Z" title="发表于 2021-10-02 20:16:19">2021-10-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/09SSM-2SpringMVC/" title="Spring MVC"><img src="/img/cover/spring.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring MVC"/></a><div class="content"><a class="title" href="/09SSM-2SpringMVC/" title="Spring MVC">Spring MVC</a><time datetime="2021-09-29T08:44:07.000Z" title="发表于 2021-09-29 16:44:07">2021-09-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/3-2%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="Leetcode 归并排序"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 归并排序"/></a><div class="content"><a class="title" href="/3-2%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="Leetcode 归并排序">Leetcode 归并排序</a><time datetime="2021-09-27T08:00:19.000Z" title="发表于 2021-09-27 16:00:19">2021-09-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 张海达</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>