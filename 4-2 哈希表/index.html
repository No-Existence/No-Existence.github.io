<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Leetcode 哈希表练习 | Insular Oasis</title><meta name="keywords" content="Leetcode,数据结构"><meta name="author" content="张海达"><meta name="copyright" content="张海达"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="4-2 哈希表理论基本操作：查找，插入，删除 解决哈希冲突开放寻址法平方探测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode 哈希表练习">
<meta property="og:url" content="https://no-existence.github.io/4-2%20%E5%93%88%E5%B8%8C%E8%A1%A8/index.html">
<meta property="og:site_name" content="Insular Oasis">
<meta property="og:description" content="4-2 哈希表理论基本操作：查找，插入，删除 解决哈希冲突开放寻址法平方探测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://no-existence.github.io/img/cover/Leetcode.png">
<meta property="article:published_time" content="2022-04-09T02:31:01.000Z">
<meta property="article:modified_time" content="2022-05-17T04:55:11.562Z">
<meta property="article:author" content="张海达">
<meta property="article:tag" content="Leetcode">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://no-existence.github.io/img/cover/Leetcode.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://no-existence.github.io/4-2%20%E5%93%88%E5%B8%8C%E8%A1%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leetcode 哈希表练习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-17 12:55:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/Leetcode.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Insular Oasis</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leetcode 哈希表练习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-09T02:31:01.000Z" title="发表于 2022-04-09 10:31:01">2022-04-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-17T04:55:11.562Z" title="更新于 2022-05-17 12:55:11">2022-05-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leetcode 哈希表练习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="4-2-哈希表"><a href="#4-2-哈希表" class="headerlink" title="4-2 哈希表"></a>4-2 哈希表</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>基本操作：查找，插入，删除</p>
<h3 id="解决哈希冲突"><a href="#解决哈希冲突" class="headerlink" title="解决哈希冲突"></a>解决哈希冲突</h3><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><h5 id="平方探测"><a href="#平方探测" class="headerlink" title="平方探测"></a>平方探测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String [] list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> [] flag;</span><br><span class="line">    <span class="keyword">private</span> Integer cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer BASE=<span class="number">131</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MOD=<span class="number">10000009</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> String [n];</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(<span class="keyword">this</span>.flag,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">hashFunc</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Integer h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            h = h*BASE+(<span class="keyword">int</span>)(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> h%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算下标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">recalculateIndex</span><span class="params">(Integer index,String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag[index] &amp;&amp; !s.equals(list[index]))&#123;</span><br><span class="line">            index = (index+t*t)%list.length;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容函数</span></span><br><span class="line">    <span class="comment">// 扩容前后同一元素存放的未必是同一个位置，要对每个元素重新哈希</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = list.length*<span class="number">2</span>;</span><br><span class="line">        HashTable h = <span class="keyword">new</span> HashTable(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]) h.insert(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.flag = h.flag;</span><br><span class="line">        <span class="keyword">this</span>.list = h.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="comment">// 当装载率达到75%时，对数组扩容以减少探测的代价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(s)%list.length;</span><br><span class="line">        hashVal = recalculateIndex(hashVal,s);</span><br><span class="line">        <span class="keyword">if</span>(flag[hashVal]==<span class="keyword">false</span>)&#123;</span><br><span class="line">            flag[hashVal]=<span class="keyword">true</span>;</span><br><span class="line">            list[hashVal]=s;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt*<span class="number">4</span>&gt;list.length*<span class="number">3</span>) expand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">find</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(s)%list.length;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag[hashVal])&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(list[hashVal])) <span class="keyword">return</span> hashVal;</span><br><span class="line">            hashVal = (hashVal+t*t)%list.length;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">            System.out.print(list[i]+<span class="string">&quot;(&quot;</span>+flag[i]+<span class="string">&quot;) &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为减少该过程带来的时间复杂度，我们做这样的操作:<br> 1.维护新旧两个数组</p>
<p> 2.每次insert新元素时在新的数组中插入</p>
<p> 3.如果需要查找旧数组中的元素x，我们在旧数组中查找，并将其在旧数组中删除，在新数组中插入x</p>
<h4 id="Hash-Buffer法"><a href="#Hash-Buffer法" class="headerlink" title="Hash Buffer法"></a>Hash Buffer法</h4><p>出现冲突的元素放到缓存中，每次扩容时再额外把缓存中的元素重新插入到新的数组中。</p>
<p>这里用Set来作为缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String [] list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> [] flag;</span><br><span class="line">    <span class="keyword">private</span> Integer cnt;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; buffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer BASE=<span class="number">131</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MOD=<span class="number">10000009</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> String [n];</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Arrays.fill(<span class="keyword">this</span>.flag,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">hashFunc</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Integer h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            h = h*BASE+(<span class="keyword">int</span>)(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> h%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容函数</span></span><br><span class="line">    <span class="comment">// 扩容前后同一元素存放的未必是同一个位置，要对每个元素重新哈希</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = list.length*<span class="number">2</span>;</span><br><span class="line">        HashTable h = <span class="keyword">new</span> HashTable(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]) h.insert(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s:buffer) h.insert(s);</span><br><span class="line">        <span class="keyword">this</span>.flag = h.flag;</span><br><span class="line">        <span class="keyword">this</span>.list = h.list;</span><br><span class="line">        <span class="keyword">this</span>.buffer = h.buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="comment">// 当装载率达到75%时，对数组扩容以减少探测的代价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(s)%list.length;</span><br><span class="line">        <span class="keyword">if</span>(flag[hashVal]==<span class="keyword">false</span>)&#123;</span><br><span class="line">            flag[hashVal]=<span class="keyword">true</span>;</span><br><span class="line">            list[hashVal]=s;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt*<span class="number">4</span>&gt;list.length*<span class="number">3</span>) expand();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!s.equals(list[hashVal]))</span><br><span class="line">            buffer.add(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(s)%list.length;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(list[hashVal])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> buffer.contains(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="line">            System.out.print(list[i]+<span class="string">&quot;(&quot;</span>+flag[i]+<span class="string">&quot;) &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链址法"><a href="#链址法" class="headerlink" title="链址法"></a>链址法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span></span>&#123;</span><br><span class="line">        String val;</span><br><span class="line">        LinkNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(String v,LinkNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = v;</span><br><span class="line">            <span class="keyword">this</span>.next =n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkNode []table ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer BASE=<span class="number">131</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MOD=<span class="number">10000009</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">new</span> LinkNode[n];</span><br><span class="line">        <span class="keyword">this</span>.cnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">hashFunc</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Integer h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)</span><br><span class="line">            h = h*BASE+(<span class="keyword">int</span>)(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> h%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容函数</span></span><br><span class="line">    <span class="comment">// 由于我们使用链表结构来存储，随着元素增加，遍历的开销会更大</span></span><br><span class="line">    <span class="comment">// 所以需要扩容哈希表,减少遍历的开销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = table.length*<span class="number">2</span>;</span><br><span class="line">        HashTable h = <span class="keyword">new</span> HashTable(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;table.length;i++)&#123;</span><br><span class="line">            LinkNode p = table[i];</span><br><span class="line">            <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                h.insert(p.val);</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.table=h.table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(s)%table.length;</span><br><span class="line">        <span class="keyword">if</span>(table[hashVal]==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        LinkNode p = table[hashVal];</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Objects.equals(p.val,s)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(s)%table.length;</span><br><span class="line">        <span class="keyword">if</span>(table[hashVal]==<span class="keyword">null</span>)&#123;</span><br><span class="line">            table[hashVal]=<span class="keyword">new</span> LinkNode(s,<span class="keyword">null</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!find(s))&#123;</span><br><span class="line">            table[hashVal]=<span class="keyword">new</span> LinkNode(s,table[hashVal]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt*<span class="number">4</span>&gt;table.length*<span class="number">3</span>) expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">            LinkNode p = table[i];</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                System.out.print(p==<span class="keyword">null</span>?<span class="string">&quot;null&quot;</span>:p.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(p!=<span class="keyword">null</span>) p=p.next;</span><br><span class="line">            &#125;<span class="keyword">while</span>(p!=<span class="keyword">null</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>O(1+log (n/size))</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>存储空间与元素数量无关。相对于传统哈希表，布隆过滤器不会在运行的过程中扩容，而是在构造完成后就确定好容器的大小。</p>
<p>将key1用三个哈希函数分别计算得哈希值h1,h2,h3，然后分别将数组中下标为h1,h2,h3得位置置为1.如果再来一个键key2，计算得到也是h1,h2,h3且对应值为1，则我们认为key1=key2。</p>
<p>如果key计算得到三个哈希位均为1，则表示该key有出现过的可能，需要再借助数据库等其他手段确认；反之，表示该key一定没有在我们的数据结构中出现过，一定是新访问的。因此布隆过滤器能起到了查杀封禁的功能。</p>
<p><img src="https://gitee.com/ji-ce-xiang/blog-image/raw/master/image-20220406205812727.png" alt="image-20220406205812727"></p>
<p>布隆过滤器的弊端是无法解决冲突问题，如果两个不同的键key1和key2计算得到的三个哈希值都一样，则无法区分key1和key2.</p>
<p>为减少空间开销，布隆过滤器底层用bitmap代替数组。</p>
<h3 id="Java内置哈希数据结构"><a href="#Java内置哈希数据结构" class="headerlink" title="Java内置哈希数据结构"></a>Java内置哈希数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造</span></span><br><span class="line">HashMap&lt;Object,Object&gt; hm = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line">hm.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);  <span class="comment">// 新增键值对</span></span><br><span class="line">hm.get(<span class="string">&quot;key&quot;</span>);   <span class="comment">// 根据键获取值</span></span><br><span class="line">hm.contains(<span class="string">&quot;key&quot;</span>); <span class="comment">// 判断键是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历元素方法1</span></span><br><span class="line">Set&lt;Object&gt; keys = hm.keySet();</span><br><span class="line"><span class="keyword">for</span>(Object key:keys)&#123;</span><br><span class="line">    hm.get(key); <span class="comment">// 获取值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历元素方法2</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Object,Object&gt; entry:hm.entrySet())&#123;</span><br><span class="line">    entry.getKey(); <span class="comment">// 获取键</span></span><br><span class="line">    entry.getValue(); <span class="comment">// 获取值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="LC705-设计哈希集合-Easy"><a href="#LC705-设计哈希集合-Easy" class="headerlink" title="LC705 设计哈希集合[Easy]"></a>LC705 设计哈希集合[Easy]</h3><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>

<p>实现 <code>MyHashSet</code> 类：</p>

<ul>
    <li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>
    <li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>
    <li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
<strong>输出：</strong>
[null, null, null, true, false, null, true, null, false]

<strong>解释：</strong>
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // 返回 True
myHashSet.contains(3); // 返回 False ，（未找到）
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // 返回 True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // 返回 False ，（已移除）</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= key &lt;= 10<sup>6</sup></code></li>
    <li>最多调用 <code>10<sup>4</sup></code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code></li>
</ul>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span></span>&#123;</span><br><span class="line">        Integer val;</span><br><span class="line">        LinkNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">()</span></span>&#123;<span class="keyword">this</span>.next=<span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(Integer v,LinkNode n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = v;</span><br><span class="line">            <span class="keyword">this</span>.next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkNode [] table ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">new</span> LinkNode[<span class="number">100</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(contains(key)) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> hashVal = key%table.length;</span><br><span class="line">        LinkNode p = table[hashVal];</span><br><span class="line">        table[hashVal] = <span class="keyword">new</span> LinkNode(key,p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = key %table.length;</span><br><span class="line">        LinkNode p = table[hashVal];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(p.val==key)&#123;</span><br><span class="line">            table[hashVal] = p.next;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode pre = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.val!=key)&#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        pre.next=p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = key%table.length;</span><br><span class="line">        LinkNode p = table[hashVal];</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val==key) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LC706-设计哈希映射-Easy"><a href="#LC706-设计哈希映射-Easy" class="headerlink" title="LC706 设计哈希映射 [Easy]"></a>LC706 设计哈希映射 [Easy]</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>

<p>实现 <code>MyHashMap</code> 类：</p>

<ul>
    <li><code>MyHashMap()</code> 用空映射初始化对象</li>
    <li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>
    <li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>
    <li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>
</ul>
<p><strong>示例：</strong></p>

<pre>
<strong>输入</strong>：
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
<strong>输出</strong>：
[null, null, null, 1, -1, null, 1, null, -1]

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= key, value &lt;= 10<sup>6</sup></code></li>
    <li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>
</ul>
#### 思路

设置一个数据结构存储`(key,value)` 对，根据key的值来哈希，这里用链址法解决哈希冲突。 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span></span>&#123;</span><br><span class="line">        Integer key;</span><br><span class="line">        Integer val;</span><br><span class="line">        LinkNode next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">()</span></span>&#123;<span class="keyword">this</span>.next=<span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(Integer k,Integer v,LinkNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = k;</span><br><span class="line">            <span class="keyword">this</span>.val = v;</span><br><span class="line">            <span class="keyword">this</span>.next =n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkNode [] list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer BASE=<span class="number">197</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer MOD=<span class="number">1000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> LinkNode[<span class="number">10000</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">hashFunc</span><span class="params">(Integer num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num*BASE%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(key)%list.length;</span><br><span class="line">        LinkNode p = list[hashVal];</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key==key) &#123;</span><br><span class="line">                p.val=value;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list[hashVal]=<span class="keyword">new</span> LinkNode(key,value,list[hashVal]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(key)%list.length;</span><br><span class="line">        LinkNode p = list[hashVal];</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key==key) <span class="keyword">return</span> p.val;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashVal = hashFunc(key)%list.length;</span><br><span class="line">        LinkNode p = list[hashVal];</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(p.key==key) &#123;</span><br><span class="line">            list[hashVal]=p.next;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode pre=p;</span><br><span class="line">        p=p.next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key==key)&#123;</span><br><span class="line">                pre.next=p.next;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





### * LC535 TinyURL 的加密与解密 [Medium]


<p>TinyURL是一种URL简化服务， 比如：当你输入一个URL&nbsp;<code>https://leetcode.com/problems/design-tinyurl</code>&nbsp;时，它将返回一个简化的URL&nbsp;<code>http://tinyurl.com/4e9iAk</code>.</p>

<p>要求：设计一个 TinyURL 的加密&nbsp;<code>encode</code>&nbsp;和解密&nbsp;<code>decode</code>&nbsp;的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。</p>


#### 思路

题意要求设计一种方法来将长串转化为短串，并且能够将得到的短串转换回来。

前一部分我们为长串随机生成一个未使用过的短串，并存到哈希表中。

后一部分我们直接查哈希表得到长串结果

注意：这里我们只用保证一个短串对应唯一的一个长串，而不用保证一个长串对应唯一一个短串，这正是我们选择哈希映射的一个理由。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,String&gt; hp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">randomString</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r= random.nextInt()%<span class="number">128</span>;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(String longUrl)</span> </span>&#123;</span><br><span class="line">        String tinyString;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            tinyString=randomString(longUrl.length());</span><br><span class="line">            <span class="keyword">if</span>(!hp.containsKey(tinyString)) &#123;</span><br><span class="line">                hp.put(tinyString,longUrl);</span><br><span class="line">                <span class="keyword">return</span> tinyString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String shortUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hp.get(shortUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### LC187 [重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)[Medium]
<p><strong>DNA序列</strong>&nbsp;由一系列核苷酸组成，缩写为<meta charset="UTF-8" />&nbsp;<code>'A'</code>,&nbsp;<code>'C'</code>,&nbsp;<code>'G'</code>&nbsp;和<meta charset="UTF-8" />&nbsp;<code>'T'</code>.。</p>

<ul>
    <li>例如，<meta charset="UTF-8" /><code>"ACGAATTCCG"</code>&nbsp;是一个 <strong>DNA序列</strong> 。</li>
</ul>

<p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p>

<p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的&nbsp;<strong>长度为&nbsp;<code>10</code></strong>&nbsp;的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
<strong>输出：</strong>["AAAAACCCCC","CCCCCAAAAA"]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "AAAAAAAAAAAAA"
<strong>输出：</strong>["AAAAAAAAAA"]
</pre>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
    <li><code>s[i]</code><code>==</code><code>'A'</code>、<code>'C'</code>、<code>'G'</code>&nbsp;or&nbsp;<code>'T'</code></li>
</ul>


<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>枚举字符串中所有长度为10的子串，借助哈希映射来统计不同子串出现的次数，再将出现次数超过1的子串放到结果集中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; hp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">10</span>&lt;=s.length();i++)&#123;</span><br><span class="line">            String sub = s.substring(i,i+<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(hp.containsKey(sub)) &#123;</span><br><span class="line">                hp.put(sub,hp.get(sub)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> hp.put(sub,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:hp.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()&gt;<span class="number">1</span>) result.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LC318-最大单词长度乘积-Medium"><a href="#LC318-最大单词长度乘积-Medium" class="headerlink" title="LC318 最大单词长度乘积[Medium]"></a>LC318 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">最大单词长度乘积</a>[Medium]</h3><p>给你一个字符串数组&nbsp;<code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code>&nbsp;的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p>

<p><strong>示例&nbsp;1：</strong></p>

<pre>
<strong>输入：</strong>words = <code>["abcw","baz","foo","bar","xtfn","abcdef"]</code>
<strong>输出：</strong><code>16 
<strong>解释</strong></code><strong>：</strong><code>这两个单词为<strong> </strong>"abcw", "xtfn"</code>。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>words = <code>["a","ab","abc","d","cd","bcd","abcd"]</code>
<strong>输出：</strong><code>4 
<strong>解释</strong></code><strong>：</strong>这两个单词为 <code>"ab", "cd"</code>。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>words = <code>["a","aa","aaa","aaaa"]</code>
<strong>输出：</strong><code>0 
<strong>解释</strong></code><strong>：</strong><code>不存在这样的两个单词。</code>
</pre>


<p><strong>提示：</strong></p>

<ul>
    <li><code>2 &lt;= words.length &lt;= 1000</code></li>
    <li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
    <li><code>words[i]</code>&nbsp;仅包含小写字母</li>
</ul>


<h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>暴力+哈希</p>
<p>暴力枚举每个字符串对(s1,s2)，借助哈希表flag[0~25]统计s1中各个字母是否出现，遍历s2的每个字符确认flag的值是否为true，如果有出现为true表明s1和s2有相同的字符，否则将长度积放到到result里比较。</p>
<p>时间复杂度$O(n^2m)$  。 n=words.length ,m=words[i].length</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> [] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.length;i++)&#123;</span><br><span class="line">            Arrays.fill(flag,<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                flag[words[i].charAt(j)-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;words.length;j++)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> f=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;words[j].length();k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag[words[j].charAt(k)-<span class="string">&#x27;a&#x27;</span>]) f=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(f)&#123;</span><br><span class="line">                    result = Math.max(result,words[i].length()*words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路二"><a href="#思路二" class="headerlink" title="* 思路二"></a>* 思路二</h4><p>位运算+哈希表</p>
<p>首先，通过位运算减少判断字符串对是否存在公共字符过程的时间开销。这里我们将每个字符串对应一个26位的二进制串（用int型变量储存）即位掩码，每个二进制位表示26个字母是否出现。判断字符串是否有公共字符，等价于两个字符串的位掩码做与运算结果为0.</p>
<p>其次，对于位掩码相同的字符串，我们只需记录最大长度，这里用哈希表即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取每个字符串的位掩码</span></span><br><span class="line">        <span class="keyword">int</span> [] bitmap = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            bitmap[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].length();j++)&#123;</span><br><span class="line">                bitmap[i] |= (<span class="number">1</span>&lt;&lt;(words[i].charAt(j)-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(hm.containsKey(bitmap[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span>(hm.get(bitmap[i])&lt;words[i].length()) hm.put(bitmap[i],words[i].length());</span><br><span class="line">            &#125;<span class="keyword">else</span> hm.put(bitmap[i],words[i].length());</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; keys = hm.keySet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key1:keys)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> key2:keys)&#123;</span><br><span class="line">                <span class="keyword">if</span>((key1&amp;key2)==<span class="number">0</span>)&#123;</span><br><span class="line">                    result =Math.max(result,hm.get(key1)*hm.get(key2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面试16-25-LRU-缓存-Medium"><a href="#面试16-25-LRU-缓存-Medium" class="headerlink" title="面试16.25   LRU 缓存 [Medium]"></a>面试16.25  <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache-lcci/"> LRU 缓存</a> [Medium]</h3><p>设计和构建一个&ldquo;最近最少使用&rdquo;缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p>

<p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>

<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>
写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>

<p><strong>示例:</strong></p>

<pre>LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
</pre>

<h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><p>单链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span></span>&#123;</span><br><span class="line">        Integer key;</span><br><span class="line">        Integer val;</span><br><span class="line">        LinkNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">()</span></span>&#123;<span class="keyword">this</span>.next=<span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(Integer k,Integer v,LinkNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key=k;</span><br><span class="line">            <span class="keyword">this</span>.val=v;</span><br><span class="line">            <span class="keyword">this</span>.next=n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带表头结点的线性链表,表头结点记录现存元素个数</span></span><br><span class="line">    <span class="keyword">private</span> LinkNode list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> LinkNode(<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        LinkNode p = list.next;</span><br><span class="line">        LinkNode pre =list;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.key!=key)&#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        pre.next = p.next;</span><br><span class="line">        p.next=list.next;</span><br><span class="line">        list.next=p;</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        LinkNode pre = list;</span><br><span class="line">        LinkNode p = list.next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.key!=key) &#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.val==cap) deleteTail();</span><br><span class="line">            <span class="comment">// 插入新结点</span></span><br><span class="line">            list.next=<span class="keyword">new</span> LinkNode(key,value,list.next);</span><br><span class="line">            list.val++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next=p.next;</span><br><span class="line">            p.next=list.next;</span><br><span class="line">            list.next=p;</span><br><span class="line">            p.val=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LinkNode pre = list;</span><br><span class="line">        LinkNode p = list.next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next=<span class="keyword">null</span>;</span><br><span class="line">        list.val--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><p>双向链表，减少单向链表deleteTail的开销</p>
<p>代码略</p>
<h4 id="思路三"><a href="#思路三" class="headerlink" title="*思路三"></a>*思路三</h4><p>哈希表+双向链表</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<ul>
<li><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
</li>
<li><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        LinkNode next;</span><br><span class="line">        LinkNode pre;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">()</span></span>&#123;<span class="keyword">this</span>.next=<span class="keyword">this</span>.pre=<span class="keyword">null</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(<span class="keyword">int</span> v,LinkNode p,LinkNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val=v;</span><br><span class="line">            <span class="keyword">this</span>.next=n;</span><br><span class="line">            <span class="keyword">this</span>.pre=p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,LinkNode&gt; hm;</span><br><span class="line">    <span class="keyword">private</span> LinkNode head;</span><br><span class="line">    <span class="keyword">private</span> LinkNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        <span class="keyword">this</span>.head=<span class="keyword">new</span> LinkNode(<span class="number">0</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.tail=<span class="keyword">new</span> LinkNode(<span class="number">0</span>,<span class="keyword">this</span>.head,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.next=<span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">this</span>.hm = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putToHead</span><span class="params">(LinkNode node)</span></span>&#123;</span><br><span class="line">        LinkNode preNode = node.pre;</span><br><span class="line">        LinkNode nextNode = node.next;</span><br><span class="line">        <span class="keyword">if</span>(preNode!=<span class="keyword">null</span>)preNode.next=nextNode;</span><br><span class="line">        <span class="keyword">if</span>(nextNode!=<span class="keyword">null</span>)nextNode.pre=preNode;</span><br><span class="line">        node.pre=head;</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next=node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail.pre==head) <span class="keyword">return</span> ;</span><br><span class="line">        LinkNode node = tail.pre;</span><br><span class="line">        node.pre.next=tail;</span><br><span class="line">        tail.pre = node.pre;</span><br><span class="line">        head.val--;</span><br><span class="line">        node.pre=node.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hm.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        LinkNode node = hm.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node.pre==<span class="keyword">null</span>&amp;&amp;node.next==<span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        putToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hm.containsKey(key))&#123;</span><br><span class="line">            LinkNode node = hm.get(key);</span><br><span class="line">            <span class="keyword">if</span>(node.pre!=<span class="keyword">null</span>&amp;&amp;node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                node.val=value;</span><br><span class="line">                putToHead(node);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head.val&gt;=capacity) deleteTail();</span><br><span class="line">        LinkNode p = <span class="keyword">new</span> LinkNode(value,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        hm.put(key,p);</span><br><span class="line">        putToHead(p);</span><br><span class="line">        head.val++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LC863-二叉树中所有距离为-K-的结点-Medium"><a href="#LC863-二叉树中所有距离为-K-的结点-Medium" class="headerlink" title="LC863 二叉树中所有距离为 K 的结点 [Medium]"></a>LC863 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">二叉树中所有距离为 K 的结点</a> [Medium]</h3><p>给定一个二叉树（具有根结点&nbsp;<code>root</code>），&nbsp;一个目标结点&nbsp;<code>target</code>&nbsp;，和一个整数值 <code>k</code> 。</p>

<p>返回到目标结点 <code>target</code> 距离为 <code>k</code> 的所有结点的值的列表。 答案可以以 <strong>任何顺序</strong> 返回。</p>


<p><strong>示例 1：</strong></p>

<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" style="height: 429px; width: 500px;" /></p>

<pre>
<strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
<strong>输出：</strong>[7,4,1]
<strong>解释：</strong>所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
</pre>


<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> root = [1], target = 1, k = 3
<strong>输出:</strong> []
</pre>

<p><strong>提示:</strong></p>

<ul>
    <li>节点数在&nbsp;<code>[1, 500]</code>&nbsp;范围内</li>
    <li><code>0 &lt;= Node.val &lt;= 500</code></li>
    <li><code>Node.val</code>&nbsp;中所有值 <strong>不同</strong></li>
    <li>目标结点&nbsp;<code>target</code>&nbsp;是树上的结点。</li>
    <li><code>0 &lt;= k &lt;= 1000</code></li>
</ul>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>哈希+二叉树DFS。</p>
<p>由于树的各结点值都不重复，我们可以为每个结点用哈希表来映射出其父节点，这一步需要DFS遍历整棵树。然后我们基于目标结点target做DFS，扩展结点时除了要扩展target的子结点外还要扩展target的父结点。为了避免重复访问，一种方法是再新建哈希表来存储每个结点是否被访问（类似vis数组）。由于树的本身型，这里用第二种方法，即在深搜过程中记录当前结点是由哪个结点扩展过来的，避免回走。下面代码用的是第二种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,TreeNode&gt; parent;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        constructParent(root);</span><br><span class="line">        dfs(target,<span class="keyword">null</span>,<span class="number">0</span>,k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructParent</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>) parent.put(root.left.val,root);</span><br><span class="line">        constructParent(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>) parent.put(root.right.val,root);</span><br><span class="line">        constructParent(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,TreeNode from,<span class="keyword">int</span> depth,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(depth==k)&#123;</span><br><span class="line">            result.add(root.val);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=from)dfs(root.left,root,depth+<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=from)dfs(root.right,root,depth+<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">if</span>(parent.get(root.val)!=from)&#123;</span><br><span class="line">            dfs(parent.get(root.val),root,depth+<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="其他练习"><a href="#其他练习" class="headerlink" title="其他练习"></a>其他练习</h2><h3 id="LC240搜索二维矩阵II-Medium"><a href="#LC240搜索二维矩阵II-Medium" class="headerlink" title="LC240搜索二维矩阵II [Medium]"></a>LC240搜索二维矩阵II [Medium]</h3><p>编写一个高效的算法来搜索&nbsp;<code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>

<ul>
    <li>每行的元素从左到右升序排列。</li>
    <li>每列的元素从上到下升序排列。</li>
</ul>
<p><b>示例 1：</b></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" />
<pre>
<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
<b>输出：</b>true
</pre>

<p><b>示例 2：</b></p>
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" />
<pre>
<b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
<b>输出：</b>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>m == matrix.length</code></li>
    <li><code>n == matrix[i].length</code></li>
    <li><code>1 &lt;= n, m &lt;= 300</code></li>
    <li><code>-10<sup>9</sup>&nbsp;&lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>
    <li>每行的所有元素从左到右升序排列</li>
    <li>每列的所有元素从上到下升序排列</li>
    <li><code>-10<sup>9</sup>&nbsp;&lt;= target &lt;= 10<sup>9</sup></code></li>
</ul>



<h4 id="思路一-2"><a href="#思路一-2" class="headerlink" title="思路一"></a>思路一</h4><p>对每行二分找答案，时间复杂度$O(nlog m)$</p>
<h4 id="思路二-2"><a href="#思路二-2" class="headerlink" title="*思路二"></a>*思路二</h4><p><img src="https://gitee.com/ji-ce-xiang/blog-image/raw/master/image-20220407181339714.png" alt="image-20220407181339714"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;m&amp;&amp;y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]==target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]&gt;target) y--;</span><br><span class="line">            <span class="keyword">else</span> x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LC-430-扁平化多级双向链表-Medium"><a href="#LC-430-扁平化多级双向链表-Medium" class="headerlink" title="LC 430 扁平化多级双向链表 [Medium]"></a>LC 430 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">扁平化多级双向链表</a> [Medium]</h3><p>你会得到一个双链表，其中包含的节点有一个下一个指针、一个前一个指针和一个额外的 <strong>子指针</strong> 。这个子指针可能指向一个单独的双向链表，也包含这些特殊的节点。这些子列表可以有一个或多个自己的子列表，以此类推，以生成如下面的示例所示的 <strong>多层数据结构</strong> 。</p>

<p>给定链表的头节点&nbsp;<font color="#c7254e"><font face="Menlo, Monaco, Consolas, Courier New, monospace"><span style="font-size:12.6px"><span style="background-color:#f9f2f4">head</span></span></font></font>&nbsp;，将链表 <strong>扁平化</strong> ，以便所有节点都出现在单层双链表中。让 <code>curr</code> 是一个带有子列表的节点。子列表中的节点应该出现在<strong>扁平化列表</strong>中的&nbsp;<code>curr</code> <strong>之后</strong> 和&nbsp;<code>curr.next</code>&nbsp;<strong>之前</strong> 。</p>

<p>返回 <em>扁平列表的 <code>head</code>&nbsp;。列表中的节点必须将其 <strong>所有</strong> 子指针设置为&nbsp;<code>null</code>&nbsp;。</em></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg" style="height:339px; width:700px" /></p>

<pre>
<strong>输入：</strong>head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
<strong>输出：</strong>[1,2,3,7,8,11,12,9,10,4,5,6]
<strong>解释：</strong>输入的多级列表如上图所示。
扁平化后的链表如下图：
<img src="https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg" style="height:69px; width:1000px" />
</pre>

<p><strong>示例 2：</strong></p>

<p><img src="https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg" style="height:200px; width:200px" /></p>

<pre>
<strong>输入：</strong>head = [1,2,null,3]
<strong>输出：</strong>[1,3,2]
<strong>解释：</strong>输入的多级列表如上图所示。
扁平化后的链表如下图：
<img src="https://assets.leetcode.com/uploads/2021/11/24/list.jpg" style="height:87px; width:300px" />
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>head = []
<strong>输出：</strong>[]
<strong>说明：</strong>输入中可能存在空列表。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li>节点数目不超过 <code>1000</code></li>
    <li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>
</ul>

<p>&nbsp;</p>

<p><strong>如何表示测试用例中的多级链表？</strong></p>

<p>以 <strong>示例 1</strong> 为例：</p>

<pre>
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL</pre>

<p>序列化其中的每一级之后：</p>

<pre>
[1,2,3,4,5,6,null]
[7,8,9,10,null]
[11,12,null]
</pre>

<p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p>

<pre>
[1,2,3,4,5,6,null]
[null,null,7,8,9,10,null]
[null,11,12,null]
</pre>

<p>合并所有序列化结果，并去除末尾的 null 。</p>

<pre>
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
</pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>递归+链表操作。</p>
<p>对于 <code>p.child==null</code> 的结点，不做处理，直接放到结果集中</p>
<p>对于 <code>p.child!=null</code> 的结点， 用flatten函数自身扁平化处理p.child后得到新的链表v，找到v的结尾结点w，设置结点w与结点<code>p.next</code>为前后结点，设置结点p和链表v的首结点为前后结点。</p>
<p>对于 <code>p.child!=null</code> 的结点后一个结点，同上用flatten函数自身处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.child==<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        Node q = p.next;</span><br><span class="line">        Node w = p;</span><br><span class="line">        Node v = flatten(p.child);</span><br><span class="line">        v.prev = p;</span><br><span class="line">        p.next = v;</span><br><span class="line">        p.child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(w.next!=<span class="keyword">null</span>) w=w.next;</span><br><span class="line">        w.next = q;</span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="keyword">null</span>)q.prev = w;</span><br><span class="line">        flatten(q);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="LC979-在二叉树中分配硬币-Medium"><a href="#LC979-在二叉树中分配硬币-Medium" class="headerlink" title="** LC979 在二叉树中分配硬币 [Medium]"></a>** LC979 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-coins-in-binary-tree/">在二叉树中分配硬币</a> [Medium]</h3><p>给定一个有 <code>N</code> 个结点的二叉树的根结点 <code>root</code>，树中的每个结点上都对应有 <code>node.val</code> 枚硬币，并且总共有 <code>N</code> 枚硬币。</p>

<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。</p>

<p>返回使每个结点上只有一枚硬币所需的移动次数。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree1.png" style="height: 142px; width: 150px;"></strong></p>

<pre><strong>输入：</strong>[3,0,0]
<strong>输出：</strong>2
<strong>解释：</strong>从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
</pre>

<p><strong>示例 2：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree2.png" style="height: 142px; width: 150px;"></strong></p>

<pre><strong>输入：</strong>[0,3,0]
<strong>输出：</strong>3
<strong>解释：</strong>从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
</pre>

<p><strong>示例 3：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree3.png" style="height: 142px; width: 150px;"></strong></p>

<pre><strong>输入：</strong>[1,0,2]
<strong>输出：</strong>2
</pre>

<p><strong>示例 4：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/tree4.png" style="height: 156px; width: 155px;"></strong></p>

<pre><strong>输入：</strong>[1,0,0,null,3]
<strong>输出：</strong>4
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
    <li><code>1&lt;= N &lt;= 100</code></li>
    <li><code>0 &lt;= node.val &lt;= N</code></li>
</ol>



<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>二叉树后序遍历。</p>
<p>定义dfs(Treenode root) 表示从以root为根节点的子树中能拿走的金币个数，如果该子树需要拿进金币，则为负数。</p>
<p>考虑对于给定的某个根结点root，它从左子树能拿到的金币数是 <code>l= dfs(root.left)</code> , 金币再左子结点到根节点的移动次数也为 l，右子树同理。根节点要保证留有一个金币，故至少需要移动 <code>root.val-1</code> 个金币。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfs(root)==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root.left);</span><br><span class="line">        result += Math.abs(l);</span><br><span class="line">        <span class="keyword">int</span> r = dfs(root.right);</span><br><span class="line">        result += Math.abs(r);</span><br><span class="line">        <span class="keyword">return</span> l+r+root.val-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>树+哈希。  </p>
<p><strong>给定一个树，而且各结点值不重复</strong>，此时可以考虑用哈希+树的组合。</p>
<p>以结点值作为键建立哈希表，值可以为对应结点指针、对应结点的父节点、该结点的附加属性（如DFS时是否访问过，BFS时所在的深度）</p>
<p>如果想按图一样搜索，可以考虑用哈希表存每个结点得父节点，而不用再重新建图。这样就可以<strong>以非根节点为起点做BFS或DFS。</strong>例题：LC863</p>
</li>
<li><p>链表+哈希。</p>
<p><strong>链表的各结点值不重复。</strong>想快速定位一个结点的位置可以建立键和结点的哈希映射。例题：面试题16.25</p>
</li>
<li><p>设计哈希映射</p>
<p>多用链址法，不必考虑扩容，删除也简单。</p>
<p>开放寻址法难点在于删除。</p>
<p>哈希缓存法需要用到语言自带的类库</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">张海达</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://no-existence.github.io/4-2%20%E5%93%88%E5%B8%8C%E8%A1%A8/">https://no-existence.github.io/4-2%20%E5%93%88%E5%B8%8C%E8%A1%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://no-existence.github.io" target="_blank">Insular Oasis</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/Leetcode.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/4-3%20%E6%B7%B1%E6%90%9C%E4%B8%8E%E5%B9%BF%E6%90%9C/"><img class="prev-cover" src="/img/cover/Leetcode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leetcode 深搜广搜练习</div></div></a></div><div class="next-post pull-right"><a href="/4-1%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"><img class="next-cover" src="/img/cover/Leetcode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Leetcode 二分法练习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/3-1快速排序及优化/" title="Leetcode 快速排序联系"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-19</div><div class="title">Leetcode 快速排序联系</div></div></a></div><div><a href="/3-4拓扑排序/" title="Leetcode 拓扑排序练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">Leetcode 拓扑排序练习</div></div></a></div><div><a href="/3-3不基于比较的排序/" title="Leetcode 不基于比较的排序的练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-05</div><div class="title">Leetcode 不基于比较的排序的练习</div></div></a></div><div><a href="/4-3 深搜与广搜/" title="Leetcode 深搜广搜练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-10</div><div class="title">Leetcode 深搜广搜练习</div></div></a></div><div><a href="/1-2 线程池与任务队列/" title="Leetcode 队列练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-20</div><div class="title">Leetcode 队列练习</div></div></a></div><div><a href="/1-1 链表及经典问题/" title="Leetcode 链表练习"><img class="cover" src="/img/cover/Leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-19</div><div class="title">Leetcode 链表练习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">张海达</div><div class="author-info__description">张海达的个人博客</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/No-Existence"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/No-Existence" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#4-2-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">4-2 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">解决哈希冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">开放寻址法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">平方探测</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash-Buffer%E6%B3%95"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Hash Buffer法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%9D%80%E6%B3%95"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">链址法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">布隆过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E7%BD%AE%E5%93%88%E5%B8%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">Java内置哈希数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.2.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LC705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88-Easy"><span class="toc-number">1.2.1.</span> <span class="toc-text">LC705 设计哈希集合[Easy]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84-Easy"><span class="toc-number">1.2.2.</span> <span class="toc-text">LC706 设计哈希映射 [Easy]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC318-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF-Medium"><span class="toc-number">1.2.3.</span> <span class="toc-text">LC318 最大单词长度乘积[Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">* 思路二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%9516-25-LRU-%E7%BC%93%E5%AD%98-Medium"><span class="toc-number">1.2.4.</span> <span class="toc-text">面试16.25   LRU 缓存 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80-1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C-1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">思路二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%89"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">*思路三</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC863-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-K-%E7%9A%84%E7%BB%93%E7%82%B9-Medium"><span class="toc-number">1.2.5.</span> <span class="toc-text">LC863 二叉树中所有距离为 K 的结点 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%83%E4%B9%A0"><span class="toc-number">1.3.</span> <span class="toc-text">其他练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LC240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II-Medium"><span class="toc-number">1.3.1.</span> <span class="toc-text">LC240搜索二维矩阵II [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80-2"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">思路一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C-2"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">*思路二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC-430-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-Medium"><span class="toc-number">1.3.2.</span> <span class="toc-text">LC 430 扁平化多级双向链表 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LC979-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81-Medium"><span class="toc-number">1.3.3.</span> <span class="toc-text">** LC979 在二叉树中分配硬币 [Medium]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/8.%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP 8 异常控制流"><img src="/img/cover/CSAPP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP 8 异常控制流"/></a><div class="content"><a class="title" href="/8.%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/" title="CSAPP 8 异常控制流">CSAPP 8 异常控制流</a><time datetime="2022-05-05T06:43:22.000Z" title="发表于 2022-05-05 14:43:22">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" title="Leetcode 练习"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 练习"/></a><div class="content"><a class="title" href="/5-3%20%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/" title="Leetcode 练习">Leetcode 练习</a><time datetime="2022-05-02T09:11:01.000Z" title="发表于 2022-05-02 17:11:01">2022-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6.%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="CSAPP 6 存储器层次结构"><img src="/img/cover/CSAPP.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSAPP 6 存储器层次结构"/></a><div class="content"><a class="title" href="/6.%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="CSAPP 6 存储器层次结构">CSAPP 6 存储器层次结构</a><time datetime="2022-04-30T08:36:12.000Z" title="发表于 2022-04-30 16:36:12">2022-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5-2%20%E5%8D%95%E8%B0%83%E6%A0%88/" title="Leetcode 单调栈练习"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 单调栈练习"/></a><div class="content"><a class="title" href="/5-2%20%E5%8D%95%E8%B0%83%E6%A0%88/" title="Leetcode 单调栈练习">Leetcode 单调栈练习</a><time datetime="2022-04-29T11:30:01.000Z" title="发表于 2022-04-29 19:30:01">2022-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/5-1%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="Leetcode 单调队列练习"><img src="/img/cover/Leetcode.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Leetcode 单调队列练习"/></a><div class="content"><a class="title" href="/5-1%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" title="Leetcode 单调队列练习">Leetcode 单调队列练习</a><time datetime="2022-04-25T04:20:01.000Z" title="发表于 2022-04-25 12:20:01">2022-04-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 张海达</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>